
from typing import Any, Dict, Optional, Sequence, Tuple, Union
Node = Any
def trace(msg: Any) -> None: ...
class Connection:
    def defaultWhenHungupHandler(self) -> None: ...
    def trace(self, msg: Any) -> None: ...
    def whenHungUp(self, thenCallFunction: Any) -> None: ...
    def call(self, addr: Any, whenHearCall: Any, port: Any=) -> None: ...
    def wait(self, whenHearCall: Any, port: Any=) -> None: ...
    def isConnected(self) -> Any: ...
        #   0: return self.connected
        # ? 0: return self.connected
    def say(self, data: Any) -> None: ...
    def hangUp(self) -> None: ...
class TextConnection(Connection):
    def __init__(self) -> None: ...
class BinaryConnection(Connection):
    def __init__(self) -> None: ...
def _startListenerThread(handle: Any, addr: Any, whenHearFn: Any, hangUpFn: Any, packetiser: Any) -> Any: ...
    #   0: return thread.start_new_thread(_listenerThreadBody,(handle, addr, whenHearFn, hangUpFn, packetiser))
    # ? 0: return thread.start_new_thread(_listenerThreadBody, Tuple[handle, addr, whenHearFn, hangUpFn, packetiser])
def _stopListenerThread(threadHandle: Any) -> None: ...
def _listenerThreadBody(handle: Any, addr: Any, whenHearFn: Any, hangUpFn: Any=, packetiser: Any=) -> None: ...
def _clientOpen(addr: Any, port: Any) -> str: ...
def _serverWait(addr: Any, port: Any) -> str: ...
def _serverAccept(handle: Any) -> Tuple[Any, Any]: ...
def _close(handle: Any) -> None: ...
def _send(handle: Any, data: Any) -> None: ...
def _receive(handle: Any, hangUpFn: Any=) -> Optional[Any]: ...
    #   0: return
    #   0: return 
    #   1: return data
    # ? 1: return data
def whenHungUp(thenCallFunction: Any) -> None: ...
def call(addr: Any, whenHearCall: Any=, port: Any=) -> None: ...
def wait(whenHearCall: Any, port: Any=) -> None: ...
def isConnected() -> Any: ...
    #   0: return conn.isConnected()
    # ? 0: return conn.isConnected()
def say(data: Any) -> None: ...
def hangUp() -> None: ...
